<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hero Adventure: Blade Master</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; font-family: sans-serif; user-select: none; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Dashboard UI */
        .dashboard { position: absolute; top: 20px; left: 20px; background: rgba(0, 40, 0, 0.6); 
                      padding: 15px; border-radius: 15px; color: white; border: 2px solid white; 
                      backdrop-filter: blur(8px); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .hp-bar { width: 150px; height: 12px; background: #1a3300; border-radius: 6px; margin-top: 8px; overflow: hidden; border: 1px solid white; }
        #hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #4ade80, #a3e635); transition: width 0.3s; }

        /* Joystick Control */
        #joy-base { position: absolute; bottom: 50px; left: 50px; width: 100px; height: 100px; 
                     background: rgba(255,255,255,0.2); border-radius: 50%; pointer-events: auto; 
                     display: flex; align-items: center; justify-content: center; border: 2px solid white; }
        #joy-stick { width: 40px; height: 40px; background: white; border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        
        /* Attack Button */
        #btn-attack { position: absolute; bottom: 55px; right: 55px; width: 95px; height: 95px; 
                       background: radial-gradient(#ff4500, #b22222); border: 4px solid white; border-radius: 50%; 
                       color: white; font-weight: bold; font-size: 16px; pointer-events: auto; 
                       box-shadow: 0 8px 20px rgba(0,0,0,0.4); }
        #btn-attack:active { transform: scale(0.85); background: #ff0000; }

        #loading { position: absolute; width: 100%; height: 100%; background: #ffffff; z-index: 100; 
                   display: flex; flex-direction: column; align-items: center; justify-content: center; color: #2d5a27; }
    </style>
</head>
<body>

    <div id="loading">
        <h1>‚öîÔ∏è CHU·∫®N B·ªä CHI·∫æN BINH...</h1>
        <p>ƒêang t·∫£i hero.glb v√† meadow.glb</p>
    </div>

    <div id="ui">
        <div class="dashboard">
            <div style="font-size: 12px; letter-spacing: 1px; font-weight: bold;">CHI·∫æN BINH ƒê·ªíNG C·ªé</div>
            <div class="hp-bar"><div id="hp-fill"></div></div>
            <div style="margin-top: 8px; font-size: 14px;">üíÄ QU√ÅI: <span id="score">0</span></div>
        </div>
        <div id="joy-base"><div id="joy-stick"></div></div>
        <button id="btn-attack">VUNG KI·∫æM</button>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- C·∫§U H√åNH ENGINE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(10, 30, 10);
        sun.castShadow = true;
        scene.add(sun);

        // --- T·∫¢I T√ÄI NGUY√äN ---
        let hero, environment, mixer, actions = {};
        let hp = 100, score = 0, isAttacking = false;
        let moveVec = new THREE.Vector2(0, 0);
        const enemies = [];
        const loader = new GLTFLoader();

        // 1. T·∫£i M√¥i tr∆∞·ªùng (Meadow)
        loader.load('meadow.glb', (gltf) => {
            environment = gltf.scene;
            // T·ª± ƒë·ªông cƒÉn ch·ªânh meadow n·∫øu n√≥ qu√° b√© (nh∆∞ trong ·∫£nh 2)
            const box = new THREE.Box3().setFromObject(environment);
            const size = box.getSize(new THREE.Vector3());
            if(size.x < 50) {
                const s = 100 / size.x;
                environment.scale.set(s, s, s);
            }
            environment.traverse(n => { if(n.isMesh) { n.receiveShadow = true; n.castShadow = true; } });
            scene.add(environment);
        }, undefined, () => {
            // Backup n·∫øu kh√¥ng c√≥ file
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(500,500), new THREE.MeshStandardMaterial({color: 0x4caf50}));
            ground.rotation.x = -Math.PI/2;
            ground.receiveShadow = true;
            scene.add(ground);
        });

        // 2. T·∫£i Hero (S·ª≠a l·ªói "chi·∫øc ƒë≈©a" v√† t∆∞ th·∫ø d∆° tay)
        loader.load('hero.glb', (gltf) => {
            hero = gltf.scene;
            
            // Fix k√≠ch th∆∞·ªõc: ƒêo chi·ªÅu cao th·ª±c t·∫ø v√† √©p v·ªÅ 2.2 ƒë∆°n v·ªã
            const box = new THREE.Box3().setFromObject(hero);
            const size = box.getSize(new THREE.Vector3());
            const scaleFactor = 2.2 / size.y;
            hero.scale.set(scaleFactor, scaleFactor, scaleFactor); // Ch·ªâ set 1 l·∫ßn duy nh·∫•t
            hero.position.y = 0;

            hero.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    // Ch·ªânh m√†u th√©p
                    child.material.metalness = 0.8;
                    child.material.roughness = 0.2;
                }
            });

            scene.add(hero);
            document.getElementById('loading').style.display = 'none';

            mixer = new THREE.AnimationMixer(hero);
            gltf.animations.forEach(clip => {
                actions[clip.name.toLowerCase()] = mixer.clipAction(clip);
            });
        });

        // --- HI·ªÜU ·ª®NG V·∫æT CH√âM (SLASH EFFECT) ---
        function createSlashEffect() {
            const geo = new THREE.TorusGeometry(1.5, 0.05, 8, 32, Math.PI);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
            const slash = new THREE.Mesh(geo, mat);
            
            slash.position.copy(hero.position);
            slash.position.y += 1.2;
            slash.rotation.y = hero.rotation.y + Math.PI/2;
            slash.rotation.x = Math.PI/2 + (Math.random() - 0.5); // Nghi√™ng ng·∫´u nhi√™n cho ƒë·∫πp
            
            scene.add(slash);

            let s = 1.0;
            const anim = () => {
                s += 0.15;
                slash.scale.set(s, s, s);
                slash.material.opacity -= 0.1;
                if(slash.material.opacity > 0) requestAnimationFrame(anim);
                else { scene.remove(slash); slash.geometry.dispose(); slash.material.dispose(); }
            };
            anim();
        }

        // --- ƒêI·ªÄU KHI·ªÇN JOYSTICK ---
        const jBase = document.getElementById('joy-base');
        const jStick = document.getElementById('joy-stick');
        let jActive = false;

        jBase.addEventListener('touchstart', e => { jActive = true; move(e); });
        window.addEventListener('touchmove', e => { if(jActive) move(e); });
        window.addEventListener('touchend', () => { 
            jActive = false; jStick.style.transform = `translate(0,0)`; moveVec.set(0,0);
        });

        function move(e) {
            const rect = jBase.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left - rect.width/2;
            const y = touch.clientY - rect.top - rect.height/2;
            const dist = Math.min(Math.sqrt(x*x+y*y), 40);
            const angle = Math.atan2(y, x);
            jStick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
            moveVec.set(Math.cos(angle)*(dist/40), -Math.sin(angle)*(dist/40));
        }

        // --- H√ÄNH ƒê·ªòNG VUNG KI·∫æM ---
        function attack() {
            if (isAttacking || !hero) return;
            isAttacking = true;
            
            createSlashEffect();

            // Ho·∫°t ·∫£nh vung ng∆∞·ªùi
            const startRot = hero.rotation.y;
            let t = 0;
            const swing = () => {
                t += 0.3;
                // Vung m·∫°nh ng∆∞·ªùi v·ªÅ tr∆∞·ªõc
                hero.rotation.y = startRot + Math.sin(t) * 1.5;
                if(t < Math.PI) requestAnimationFrame(swing);
                else { hero.rotation.y = startRot; isAttacking = false; }
            };
            swing();

            enemies.forEach((en, i) => {
                if(hero.position.distanceTo(en.position) < 4.5) {
                    scene.remove(en); enemies.splice(i, 1);
                    score += 10; document.getElementById('score').innerText = score;
                }
            });
        }
        document.getElementById('btn-attack').onclick = attack;

        // --- QU√ÅI V·∫¨T ---
        function spawnEnemy() {
            if(!hero) return;
            const en = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color: 0xff0000}));
            const a = Math.random()*Math.PI*2;
            en.position.set(hero.position.x + Math.cos(a)*25, 0.5, hero.position.z + Math.sin(a)*25);
            scene.add(en); enemies.push(en);
        }
        setInterval(spawnEnemy, 4000);

        // --- V√íNG L·∫∂P CH√çNH ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = performance.now() * 0.001;
            if (mixer) mixer.update(delta);

            if (hero) {
                // DI CHUY·ªÇN & HO·∫†T ·∫¢NH CH·∫†Y
                if (moveVec.length() > 0.1 && !isAttacking) {
                    hero.position.x += moveVec.x * 0.18;
                    hero.position.z -= moveVec.y * 0.18;
                    const targetAngle = Math.atan2(moveVec.x, moveVec.y);
                    hero.rotation.y = THREE.MathUtils.lerp(hero.rotation.y, targetAngle, 0.2);
                    
                    // Ho·∫°t ·∫£nh ch·∫°y nh·∫•p nh√¥ (Kh√¥ng d√πng scale)
                    hero.position.y = Math.abs(Math.sin(time * 15)) * 0.2; 
                    hero.rotation.z = Math.sin(time * 15) * 0.05; // Nghi√™ng ng∆∞·ªùi
                } else if(!isAttacking) {
                    // ƒê·ª®NG Y√äN (Th·ªü nh·∫π b·∫±ng position.y)
                    hero.position.y = Math.sin(time * 2) * 0.05;
                    hero.rotation.z = 0;
                    // B·∫ª t∆∞ th·∫ø tay h·∫° xu·ªëng: Xoay model h∆°i c√∫i v·ªÅ tr∆∞·ªõc
                    hero.rotation.x = 0.15; 
                }

                // Camera follow chu·∫©n (Kh√¥ng qu√° xa)
                camera.position.lerp(new THREE.Vector3(hero.position.x, hero.position.y + 10, hero.position.z + 16), 0.1);
                camera.lookAt(hero.position);

                enemies.forEach(en => {
                    const d = new THREE.Vector3().subVectors(hero.position, en.position).normalize();
                    en.position.add(d.multiplyScalar(0.08));
                    if(en.position.distanceTo(hero.position) < 1.5) {
                        hp -= 0.1;
                        document.getElementById('hp-fill').style.width = Math.max(0, hp) + "%";
                    }
                });
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>